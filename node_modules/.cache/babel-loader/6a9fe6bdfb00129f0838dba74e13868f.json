{"ast":null,"code":"import _toConsumableArray from \"/Users/drenyasova/diplome/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\n/**\n * Calculate amount of metrics for layout\n * @param questions - questions object from the dashboard\n * @returns array with total amount of metrics and array with metrics amount on each pane\n */\nexport function getMetricsAmount(questions) {\n  var meticsOnPane = [];\n  questions.map(function (q) {\n    return meticsOnPane.push(q.metrics.length);\n  });\n  var metrics = meticsOnPane.reduce(function (a, b) {\n    return a + b;\n  }, 0);\n  return [meticsOnPane, metrics];\n}\n\n/**\n * Generate item layout properties\n * (Check react-grid-layout grid item props)\n * @param ind - index of metric\n * @param width - how much columns should the metric take\n * @param metricsOnPane - amount of metrics on each pane\n * @returns item property for grid layout\n */\nexport function getMetricLayout(ind, width, metricsOnPane) {\n  var indexOnPage = ind;\n  var _iterator = _createForOfIteratorHelper(metricsOnPane),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var m = _step.value;\n      if (indexOnPage >= m) indexOnPage -= m;else break;\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return {\n    i: ind.toString(),\n    x: width * indexOnPage,\n    y: 0,\n    w: width,\n    h: 1,\n    //height=408px\n    minW: width,\n    resizeHandles: [\"e\"] //Resizable to the right(east)\n  };\n}\n\n/**\n * Generate layout of metrics for react grid\n * (Check react-grid-layout grid layout props)\n * @param itemsAmount - amount of metrics\n * @param width - how much columns should each metric take\n * @param metricsOnPane - amount of metrics on each pane\n * @returns grid layout\n */\nexport function getLayout(itemsAmount, width, metricsOnPane) {\n  var layout = [];\n  var j = 0;\n  for (var _i = 0, _arr = _toConsumableArray(Array(itemsAmount).keys()); _i < _arr.length; _i++) {\n    var i = _arr[_i];\n    if (typeof width === \"object\") {\n      layout.push(getMetricLayout(i, width[j], metricsOnPane));\n      if (width.length !== j + 1) j += 1;\n    } else {\n      layout.push(getMetricLayout(i, width, metricsOnPane));\n    }\n  }\n  return layout;\n}\n\n/**\n * Compact layout if there is enough empty space in row for element\n * @param layout - changed layout (Check react-grid-layout layout props)\n * @param metricsOnPane - amount of metrics on each pane\n * @param columns - amount of columns\n */\nexport function compactLayout(layout, metricsOnPane, columns) {\n  var iter = 0;\n  for (var paneInd in metricsOnPane) {\n    //Find metrics on pane and sort them according to position on the screen\n    //(from top to bottom from left to right)\n    var paneMetricsLayouts = layout.slice(iter, iter + metricsOnPane[paneInd]);\n    paneMetricsLayouts.sort(function (el1, el2) {\n      return el1.x < el2.x ? -1 : 1;\n    }); // sort by x\n    paneMetricsLayouts.sort(function (el1, el2) {\n      return el1.y < el2.y ? -1 : 1;\n    }); // sort by y\n    //Go through them and try to push element to the top if there is enough space\n    var currY = 0;\n    var currMetricInd = 0;\n    var totalW = 0;\n    var rowShift = 0; //How much elements should be shifted to the left\n    var nextRowProcessingFlag = false;\n    while (currMetricInd < paneMetricsLayouts.length) {\n      var currMetric = paneMetricsLayouts[currMetricInd];\n      if (currMetric.y === currY) {\n        //Element on current row\n        totalW += currMetric.w;\n        currMetricInd += 1;\n        currMetric.x -= rowShift;\n      } else {\n        if (!nextRowProcessingFlag) {\n          //When transitioning from current row to next row\n          rowShift = 0;\n        }\n        if (totalW + currMetric.w <= columns) {\n          //Element from next row can be pushed to the current\n          currMetric.y = currY;\n          currMetric.x = totalW;\n          totalW += currMetric.w;\n          currMetricInd += 1;\n          nextRowProcessingFlag = true;\n          rowShift += currMetric.w;\n        } else {\n          //Element from next row cannot be pushed to the current\n          currY += 1;\n          totalW = 0;\n          nextRowProcessingFlag = false;\n        }\n      }\n    }\n    iter += metricsOnPane[paneInd];\n  }\n}\nexport function saveLaoutsToLS(value, idx, metricsOnPane, metricsAmount) {\n  if (global.localStorage) {\n    global.localStorage.setItem(\"metrics-layout\" + idx, JSON.stringify({\n      layouts: value,\n      metricsAmount: [metricsOnPane, metricsAmount]\n    }));\n  }\n}\nexport function getLayoutsFromLS(idx, metricsOnPane, metricsAmount) {\n  var ls = {};\n  if (global.localStorage) {\n    try {\n      ls = JSON.parse(global.localStorage.getItem(\"metrics-layout\" + idx)) || {};\n    } catch (e) {}\n  }\n  if (JSON.stringify(ls[\"metricsAmount\"]) === JSON.stringify([metricsOnPane, metricsAmount])) return ls[\"layouts\"];else return false;\n}","map":{"version":3,"names":["getMetricsAmount","questions","meticsOnPane","map","q","push","metrics","length","reduce","a","b","getMetricLayout","ind","width","metricsOnPane","indexOnPage","_iterator","_createForOfIteratorHelper","_step","s","n","done","m","value","err","e","f","i","toString","x","y","w","h","minW","resizeHandles","getLayout","itemsAmount","layout","j","_i","_arr","_toConsumableArray","Array","keys","compactLayout","columns","iter","paneInd","paneMetricsLayouts","slice","sort","el1","el2","currY","currMetricInd","totalW","rowShift","nextRowProcessingFlag","currMetric","saveLaoutsToLS","idx","metricsAmount","global","localStorage","setItem","JSON","stringify","layouts","getLayoutsFromLS","ls","parse","getItem"],"sources":["/Users/drenyasova/diplome/src/views/NewDashboard/GQM/GQMWrapperUtils.js"],"sourcesContent":["/**\n * Calculate amount of metrics for layout\n * @param questions - questions object from the dashboard\n * @returns array with total amount of metrics and array with metrics amount on each pane\n */\nexport function getMetricsAmount(questions) {\n  let meticsOnPane = [];\n  questions.map((q) => meticsOnPane.push(q.metrics.length));\n  const metrics = meticsOnPane.reduce((a, b) => a + b, 0);\n  return [meticsOnPane, metrics];\n}\n\n/**\n * Generate item layout properties\n * (Check react-grid-layout grid item props)\n * @param ind - index of metric\n * @param width - how much columns should the metric take\n * @param metricsOnPane - amount of metrics on each pane\n * @returns item property for grid layout\n */\nexport function getMetricLayout(ind, width, metricsOnPane) {\n  let indexOnPage = ind;\n  for (let m of metricsOnPane) {\n    if (indexOnPage >= m) indexOnPage -= m;\n    else break;\n  }\n  return {\n    i: ind.toString(),\n    x: width * indexOnPage,\n    y: 0,\n    w: width,\n    h: 1, //height=408px\n    minW: width,\n    resizeHandles: [\"e\"], //Resizable to the right(east)\n  };\n}\n\n/**\n * Generate layout of metrics for react grid\n * (Check react-grid-layout grid layout props)\n * @param itemsAmount - amount of metrics\n * @param width - how much columns should each metric take\n * @param metricsOnPane - amount of metrics on each pane\n * @returns grid layout\n */\nexport function getLayout(itemsAmount, width, metricsOnPane) {\n  let layout = [];\n  let j = 0;\n  for (let i of [...Array(itemsAmount).keys()]) {\n    if (typeof width === \"object\") {\n      layout.push(getMetricLayout(i, width[j], metricsOnPane));\n      if (width.length !== j + 1) j += 1;\n    } else {\n      layout.push(getMetricLayout(i, width, metricsOnPane));\n    }\n  }\n  return layout;\n}\n\n/**\n * Compact layout if there is enough empty space in row for element\n * @param layout - changed layout (Check react-grid-layout layout props)\n * @param metricsOnPane - amount of metrics on each pane\n * @param columns - amount of columns\n */\nexport function compactLayout(layout, metricsOnPane, columns) {\n  let iter = 0;\n  for (let paneInd in metricsOnPane) {\n    //Find metrics on pane and sort them according to position on the screen\n    //(from top to bottom from left to right)\n    let paneMetricsLayouts = layout.slice(iter, iter + metricsOnPane[paneInd]);\n    paneMetricsLayouts.sort((el1, el2) => (el1.x < el2.x ? -1 : 1)); // sort by x\n    paneMetricsLayouts.sort((el1, el2) => (el1.y < el2.y ? -1 : 1)); // sort by y\n    //Go through them and try to push element to the top if there is enough space\n    let currY = 0;\n    let currMetricInd = 0;\n    let totalW = 0;\n    let rowShift = 0; //How much elements should be shifted to the left\n    let nextRowProcessingFlag = false;\n    while (currMetricInd < paneMetricsLayouts.length) {\n      const currMetric = paneMetricsLayouts[currMetricInd];\n      if (currMetric.y === currY) {\n        //Element on current row\n        totalW += currMetric.w;\n        currMetricInd += 1;\n        currMetric.x -= rowShift;\n      } else {\n        if (!nextRowProcessingFlag) {\n          //When transitioning from current row to next row\n          rowShift = 0;\n        }\n        if (totalW + currMetric.w <= columns) {\n          //Element from next row can be pushed to the current\n          currMetric.y = currY;\n          currMetric.x = totalW;\n          totalW += currMetric.w;\n          currMetricInd += 1;\n          nextRowProcessingFlag = true;\n          rowShift += currMetric.w;\n        } else {\n          //Element from next row cannot be pushed to the current\n          currY += 1;\n          totalW = 0;\n          nextRowProcessingFlag = false;\n        }\n      }\n    }\n    iter += metricsOnPane[paneInd];\n  }\n}\n\nexport function saveLaoutsToLS(value, idx, metricsOnPane, metricsAmount) {\n  if (global.localStorage) {\n    global.localStorage.setItem(\n      \"metrics-layout\" + idx,\n      JSON.stringify({\n        layouts: value,\n        metricsAmount: [metricsOnPane, metricsAmount],\n      })\n    );\n  }\n}\n\nexport function getLayoutsFromLS(idx, metricsOnPane, metricsAmount) {\n  let ls = {};\n  if (global.localStorage) {\n    try {\n      ls =\n        JSON.parse(global.localStorage.getItem(\"metrics-layout\" + idx)) || {};\n    } catch (e) {}\n  }\n  if (\n    JSON.stringify(ls[\"metricsAmount\"]) ===\n    JSON.stringify([metricsOnPane, metricsAmount])\n  )\n    return ls[\"layouts\"];\n  else return false;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}